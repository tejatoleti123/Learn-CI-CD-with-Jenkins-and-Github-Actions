# GitHub Actions – Workflows

This document explains **GitHub Actions workflows** in detail.

A workflow is the **core unit of automation** in GitHub Actions. Understanding workflows properly will make everything else: jobs, steps, runners, and hands-on labs — feel natural.

At this stage, the goal is **clarity**, not memorization.

---

## What Is a Workflow?

A **workflow** is a definition of **what automation should happen and when**.

A workflow tells GitHub:
- When automation should start
- What tasks should be executed
- Where those tasks should run

In simple terms:
> A workflow is the **CI/CD pipeline definition** in GitHub Actions.

---

## What a Workflow Controls

A workflow controls three main things:

1. **Trigger**  
   What event should start automation

2. **Jobs**  
   What logical units of work should run

3. **Execution Environment**  
   Where the jobs should run (runner)

Everything in GitHub Actions revolves around these three ideas.

---

## Where Workflows Are Stored

All workflows live inside the repository at:

    .github/workflows/

Important rules:
- Workflow files use the `.yml` or `.yaml` extension
- Multiple workflows can exist in the same repository
- Each workflow runs independently

This means a single repository can have:
- One workflow for CI
- One workflow for deployments
- One workflow for scheduled tasks

---

## Basic Workflow Structure (Conceptual)

A workflow is made up of the following sections:

- name
- on (event trigger)
- jobs
- steps (inside jobs)

At a very high level, a workflow looks like this:

    name: Example Workflow

    on: push

    jobs:
      example-job:
        runs-on: ubuntu-latest
        steps:
          - name: Run a command
            run: echo "Hello World"

Do **not** worry about syntax yet.  
Focus on **structure and flow**.

---

## Workflow Section: name

The `name` field:
- Is optional but recommended
- Provides a human-readable name
- Appears in the GitHub Actions UI

Example:

    name: CI Workflow

This helps teams quickly understand **what the workflow does**.

---

## Workflow Section: on (Triggers)

The `on` section defines **when the workflow should run**.

GitHub Actions is **event-driven**, meaning workflows start when something happens.

Common trigger examples:
- Code is pushed to a branch
- A pull request is created or updated
- A workflow is triggered manually
- A scheduled time occurs

Example:

    on: push

This means:
> “Run this workflow whenever code is pushed.”

More advanced triggers will be covered in later files.

---

## Workflow Section: jobs

The `jobs` section defines **what work should be done**.

Important points about jobs:
- A workflow can have one or many jobs
- Jobs run **in parallel by default**
- Each job runs on its own runner
- Jobs contain steps

Example:

    jobs:
      build-job:
        runs-on: ubuntu-latest
        steps:
          - name: Build step
            run: echo "Building application"

---

## Jobs and Runners (Key Relationship)

Every job **must specify a runner**.

The runner is the machine that executes the job.

Example:

    runs-on: ubuntu-latest

This tells GitHub:
> “Run this job on a GitHub-managed Linux machine.”

Runners will be explained in depth in the **next file**.

---

## Workflow Section: steps

Steps are the **individual actions inside a job**.

Key characteristics:
- Steps run **in order**
- If a step fails, the job fails
- Steps can:
  - Run shell commands
  - Use reusable actions

Example:

    steps:
      - name: Print message
        run: echo "Hello from GitHub Actions"

Each step represents **one unit of work**.

---

## Workflow Execution Flow (End-to-End)

When a workflow runs, this is what happens internally:

1. An event occurs in GitHub  
2. GitHub checks if a workflow listens for that event  
3. The workflow is triggered  
4. Jobs are created  
5. Runners are assigned  
6. Steps are executed in order  
7. Results are reported back to GitHub  

This flow is **automatic and consistent**.

---

## Visual Execution Flow (Conceptual)

    Event occurs
         ↓
    Workflow triggered
         ↓
    Job created
         ↓
    Runner assigned
         ↓
    Steps executed
         ↓
    Status reported to GitHub

This is the **mental model** you should keep.

---

## Job Status and Feedback

Each job ends with a status:
- Success
- Failure
- Cancelled

GitHub displays:
- Logs per step
- Execution time
- Failure reasons

This feedback loop is the core of **Continuous Integration**.

---

## Best Practices (Early Stage)

When starting with workflows:

- Keep workflows simple
- Use clear and descriptive names
- One responsibility per job
- Avoid hardcoding secrets
- Prefer readability over cleverness

Complexity can be added later.

---

## Common Beginner Mistakes

Avoid these early mistakes:
- Writing everything in one huge job
- Copying workflows without understanding
- Hardcoding credentials
- Overusing advanced syntax too early

Foundations matter more than features.

---

## Key Takeaways

- A workflow defines CI/CD automation
- Workflows are event-driven
- Jobs define logical work units
- Steps define actual commands
- Runners execute the jobs

If you understand workflows,  
GitHub Actions becomes **predictable and controllable**.

---

## What’s Next?

In the next section, we will focus entirely on **runners**:
- What they are
- How they work
- GitHub-hosted vs self-hosted runners
- When to use each

This will complete the **execution model** of GitHub Actions.
