# Jenkins – Introduction and Architecture

This document introduces **Jenkins as a CI/CD tool** and explains **how it is structured internally**.

At this stage, the goal is **understanding**, not configuration or pipelines.

---

## What is Jenkins?

Jenkins is an **open-source automation server** used to implement CI/CD pipelines.

In simple terms, Jenkins:
- Watches for changes in source code
- Automatically runs defined steps (build, test, deploy)
- Provides feedback on whether those steps succeed or fail

Jenkins acts as an **automation engine** that executes the CI/CD process you define.

---

## Why Jenkins exists

Before tools like Jenkins:
- Builds were triggered manually
- Testing was inconsistent
- Deployments depended on individuals
- Processes varied between environments

Jenkins was created to:
- Automate repetitive tasks
- Standardize build and deployment processes
- Reduce human error
- Provide visibility into the software delivery lifecycle

---

## What Jenkins is commonly used for

Jenkins is commonly used to automate:

- Application builds
- Automated testing
- Code quality checks
- Packaging applications
- Deploying to environments (test, staging, production)

Jenkins itself does **not** decide *what* to do —  
it executes **steps defined by you**.

---

## Jenkins Architecture (High-Level)

Jenkins uses a **Controller–Agent architecture**.

This design separates:
- **Management and orchestration**
- **Actual execution of work**

---

### Jenkins Controller

The **Jenkins Controller** is the central component.

Responsibilities include:
- Providing the Web UI
- Storing job and pipeline definitions
- Scheduling when jobs should run
- Deciding **which agent** should execute a job
- Managing plugins and global configuration

The controller **does not usually perform heavy build work**.

---

### Jenkins Agent

A **Jenkins Agent** is a machine that performs the actual work.

Responsibilities include:
- Running build commands
- Executing tests
- Creating artifacts
- Performing deployments

Agents:
- Can run on Linux or Windows
- Can be physical machines, virtual machines, or containers
- Can be on-premises or in the cloud

Multiple agents allow Jenkins to run jobs **in parallel**.

---

## Why Jenkins uses Controller–Agent architecture

This architecture provides:

- Better scalability
- Improved performance
- Isolation between jobs
- Support for multiple platforms
- Centralized control with distributed execution

In real environments, this is critical for reliability.

---

## Jenkins in real-world environments

In practice, Jenkins is commonly set up as follows:

- One Jenkins Controller running on a server or VM
- Multiple Jenkins Agents attached to the controller
- Integration with a source control system (Git)
- Integration with cloud platforms or on-prem infrastructure

This setup allows teams to scale builds as demand increases.

---

## Why Jenkins is still relevant today

Even with newer CI/CD tools available:

- Jenkins works with **any source control system**
- Jenkins supports **highly customized workflows**
- Jenkins has a massive plugin ecosystem
- Jenkins is tool-agnostic and platform-agnostic

Jenkins is especially valuable when:
- Complex build logic is required
- Legacy systems are involved
- Full control over the CI/CD process is needed

---

## Key takeaway

- Jenkins is an automation server, not just a build tool
- It executes CI/CD workflows defined by you
- Its Controller–Agent architecture enables scalability and flexibility

In the next section, we will move from **concepts to action** by installing and setting up Jenkins step by step.
