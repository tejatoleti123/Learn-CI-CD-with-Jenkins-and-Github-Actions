# GitHub Actions – Hands-on (From Scratch to End)

This document is the **hands-on conclusion** of the GitHub Actions section.

Here, you will:
- Build a real CI workflow using GitHub Actions
- Use an example GitHub repository
- Run builds and tests automatically
- Simulate failures
- Understand results clearly
- Compare GitHub Actions with Jenkins

No assumptions are made.  
Every step is explained.

---

## What We Are Building

We will create a **basic Continuous Integration (CI) workflow** that:

- Triggers on code push
- Pulls source code
- Runs a build script
- Runs a test script
- Reports success or failure

This is the **same CI logic** you implemented earlier using Jenkins.

---

## Prerequisites

Before starting, ensure you have:

- A GitHub account
- A public GitHub repository
- Basic Git knowledge (clone, commit, push)
- No Jenkins required for this section

---

# PART 1 – PREPARE THE EXAMPLE REPOSITORY

## Step 1: Use the Existing CI Demo Repository

Use the same repository created earlier:

    jenkins-ci-demo

Repository structure should look like this:

    jenkins-ci-demo/
    ├── app.sh
    ├── test.sh
    └── README.md

If you don’t have it, recreate it using the Jenkins section.

---

## Step 2: Verify Scripts

Ensure the scripts are executable.

`app.sh`:

    #!/bin/bash
    echo "Building application..."
    echo "Build completed successfully"

`test.sh`:

    #!/bin/bash
    echo "Running tests..."
    echo "All tests passed"
    exit 0

Commit and push if needed:

    git add .
    git commit -m "Prepare scripts for GitHub Actions"
    git push origin main

---

# PART 2 – CREATE YOUR FIRST GITHUB ACTIONS WORKFLOW

## Step 3: Create Workflow Directory

Inside the repository, create the workflow directory:

    .github/workflows/

Create a file named:

    ci.yml

Final structure:

    .github/workflows/ci.yml

---

## Step 4: Define the Workflow (ci.yml)

Add the following content to `ci.yml`:

    name: CI Pipeline

    on:
      push:
        branches:
          - main

    jobs:
      ci-job:
        runs-on: ubuntu-latest

        steps:
          - name: Checkout source code
            uses: actions/checkout@v4

          - name: Run build
            run: ./app.sh

          - name: Run tests
            run: ./test.sh

---

## Step 5: Commit and Push the Workflow

    git add .github/workflows/ci.yml
    git commit -m "Add GitHub Actions CI workflow"
    git push origin main

At this point:
- No button click is required
- GitHub Actions triggers automatically

---

# PART 3 – OBSERVE WORKFLOW EXECUTION

## Step 6: View Workflow Run in GitHub

1. Go to your repository on GitHub
2. Click the **Actions** tab
3. Select **CI Pipeline**
4. Open the latest run

You will see:
- Job execution status
- Step-by-step logs
- Execution time

This is your **CI feedback loop**.

---

## Step 7: Understand What Happened

Behind the scenes:

1. Code was pushed
2. GitHub detected the `push` event
3. Workflow was triggered
4. GitHub-hosted runner was provisioned
5. Scripts were executed
6. Status was reported back

This is **real CI behavior**.

---

# PART 4 – SIMULATE A FAILURE (VERY IMPORTANT)

## Step 8: Introduce a Test Failure

Edit `test.sh`:

    exit 1

Commit and push:

    git commit -am "Simulate test failure"
    git push origin main

---

## Step 9: Observe Failure

Go back to the **Actions** tab.

You will see:
- Workflow marked as **Failed**
- Test step highlighted in red
- Logs showing failure point

Key learning:
- GitHub Actions stops execution on failure
- Clear feedback is provided
- Broken code does not proceed silently

---

# PART 5 – FIX THE FAILURE

## Step 10: Restore Test Script

Update `test.sh`:

    exit 0

Commit and push again:

    git commit -am "Fix test failure"
    git push origin main

Workflow should now pass successfully.

---

# PART 6 – CONNECTING GITHUB ACTIONS WITH JENKINS CONCEPTS

## Concept Mapping (Very Important)

| Jenkins | GitHub Actions |
|------|----------------|
| Pipeline | Workflow |
| Stage | Job / Step |
| Agent | Runner |
| Jenkinsfile | YAML Workflow |
| Console Output | Workflow Logs |

If you understand Jenkins,  
GitHub Actions will now feel **familiar**.

---

## What You Have Learned

By completing this hands-on section, you now know how to:

- Create GitHub Actions workflows
- Trigger CI on Git events
- Use GitHub-hosted runners
- Debug failures
- Read logs confidently
- Compare Jenkins and GitHub Actions logically

---

## Why This Is a Real-World CI Example

This workflow represents:
- Real CI pipelines used in teams
- Real failure handling
- Real feedback loops
- Real automation patterns

The application is simple.  
The **process is real**.

---

## Final Outcome

You have now completed:

- CI/CD fundamentals
- Jenkins (setup, jobs, pipelines, real projects)
- GitHub Actions (concepts, workflows, runners, hands-on)

You can confidently say:
> “I understand how CI/CD works in practice.”

---

## What Comes Next (Beyond This Repository)

In advanced repositories, you will explore:
- Docker-based CI/CD
- Secure secrets handling
- Multi-environment deployments
- GitHub Actions + cloud services
- Full end-to-end CI/CD systems

---

## Final Thought

Tools change.  
Workflows evolve.  
**Foundations last.**

If you can build CI in Jenkins **and** GitHub Actions,  
you are thinking like a real DevOps engineer.

