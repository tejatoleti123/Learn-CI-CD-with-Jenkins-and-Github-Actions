# Jenkins Real-World CI/CD Project – From Scratch to End (With Example Repos)

This document connects **everything you’ve learned so far** and guides you through:
- A real-world CI/CD mindset
- Two small but realistic Jenkins projects
- Example Git repositories
- Clear steps from **GitHub → Jenkins → Build Result**

By the end, you will **not guess how Jenkins works** — you will *know*.

---

## What We Are Going to Build

We will implement **two CI projects** using the **same source code**:

1. **Freestyle CI Project** (UI-based)
2. **Pipeline CI Project** (Jenkinsfile, Pipeline-as-Code)

Both projects will:
- Pull code from GitHub
- Run build steps
- Simulate tests
- Show success or failure clearly

---

## Prerequisites (Very Important)

Before starting:
- Jenkins installed and running
- GitHub account
- Basic Git knowledge (`clone`, `add`, `commit`, `push`)
- Internet access from Jenkins server

No Docker. No cloud complexity.

---

# PART 1 – CREATE THE EXAMPLE GIT REPOSITORY

## Step 1: Create a New GitHub Repository

Create a **public GitHub repository**:

Repository name:

    jenkins-ci-demo

Do NOT initialize with README (we’ll create files manually).

---

## Step 2: Clone the Repository Locally

On your local machine:

    git clone https://github.com/<your-username>/jenkins-ci-demo.git
    cd jenkins-ci-demo

---

## Step 3: Create Project Structure

Inside the repository, create the following structure:

    jenkins-ci-demo/
    ├── app.sh
    ├── test.sh
    └── README.md

---

## Step 4: Create Application Script (app.sh)

Create `app.sh`:

    #!/bin/bash
    echo "Building application..."
    echo "Application build completed successfully"

Make it executable:

    chmod +x app.sh

---

## Step 5: Create Test Script (test.sh)

Create `test.sh`:

    #!/bin/bash
    echo "Running tests..."
    echo "All tests passed successfully"
    exit 0

(To simulate failure later, we will change `exit 0` to `exit 1`.)

Make it executable:

    chmod +x test.sh

---

## Step 6: Add README.md (Optional but Helpful)

    echo "# Jenkins CI Demo Repository" > README.md

---

## Step 7: Commit and Push Code

    git add .
    git commit -m "Initial CI demo application"
    git push origin main

Your example repository is now ready.

---

# PART 2 – MINI PROJECT 1: JENKINS FREESTYLE CI JOB

## Goal of This Project

Automatically:
- Pull code from GitHub
- Run build script
- Run test script
- Mark build SUCCESS or FAILURE

---

## Step 1: Create Freestyle Job in Jenkins

1. Click **New Item**
2. Enter name: `freestyle-ci-demo`
3. Select **Freestyle project**
4. Click **OK**

---

## Step 2: Configure Source Code Management

- Select **Git**
- Repository URL:

    https://github.com/<your-username>/jenkins-ci-demo.git

- Branch: `main`

This tells Jenkins **where the code lives**.

---

## Step 3: Configure Build Steps

Add **Execute Shell** build step:

    echo "Starting CI build"
    ./app.sh
    ./test.sh

What Jenkins does here:
- Executes scripts pulled from GitHub
- Stops immediately if any script fails

---

## Step 4: Run the Freestyle Job

Click **Build Now**.

Expected result:
- Build Status: **SUCCESS**
- Console Output shows build and test logs

---

## Step 5: Simulate a Failure (Very Important)

Edit `test.sh`:

    exit 1

Commit and push again:

    git commit -am "Simulate test failure"
    git push origin main

Trigger the Jenkins job again.

Observe:
- Build fails
- Console Output shows failure
- Jenkins stops execution immediately

This is **real CI behavior**.

---

## What You Learned (Freestyle Job)

- Jenkins pulls code from Git
- Jenkins executes shell scripts
- Failures stop the job
- Logs are your primary debugging tool

---

# PART 3 – MINI PROJECT 2: JENKINS PIPELINE CI JOB

## Goal of This Project

Implement the **same CI logic**, but:
- As code
- Stored in Git
- Version controlled

This is how **modern teams work**.

---

## Step 1: Add Jenkinsfile to Repository

Create a file named `Jenkinsfile`:

    pipeline {
        agent any

        stages {
            stage('Checkout') {
                steps {
                    echo 'Source code checked out'
                }
            }

            stage('Build') {
                steps {
                    sh './app.sh'
                }
            }

            stage('Test') {
                steps {
                    sh './test.sh'
                }
            }
        }
    }

Commit and push:

    git add Jenkinsfile
    git commit -m "Add Jenkins pipeline"
    git push origin main

---

## Step 2: Create Pipeline Job in Jenkins

1. Click **New Item**
2. Name: `pipeline-ci-demo`
3. Select **Pipeline**
4. Click **OK**

Pipeline configuration:
- Definition: **Pipeline script from SCM**
- SCM: **Git**
- Repository URL:

    https://github.com/<your-username>/jenkins-ci-demo.git

- Branch: `main`
- Script Path: `Jenkinsfile`

Save the job.

---

## Step 3: Run the Pipeline

Click **Build Now**.

Observe:
- Stages execute in order
- Failed stages are highlighted
- Logs are grouped per stage

---

## Step 4: Compare Freestyle vs Pipeline

Freestyle:
- Configured in UI
- Hard to track changes
- Not scalable

Pipeline:
- Defined as code
- Version controlled
- Repeatable
- Industry standard

---

## Why This Is a Real-World CI/CD Example

This is exactly how CI works in companies:
- Developers push code
- CI runs automatically
- Failures stop bad code early
- Feedback is immediate

The application is simple —  
the **process is real**.

---

## Final Outcome

By completing this document, you can:
- Create real Jenkins CI jobs
- Debug failures confidently
- Convert UI jobs into pipelines
- Understand CI/CD flows end-to-end

You now have a **solid Jenkins foundation**.

---

## What Comes Next

In the continuation repository:
- Docker with Jenkins
- Secure credentials
- Multi-agent pipelines
- GitHub Actions
- Full end-to-end CI/CD projects

---

## Final Thought

If you understand **this flow**,  
you can learn **any CI/CD tool** with confidence.

This is how real DevOps learning should feel.

